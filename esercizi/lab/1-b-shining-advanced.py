# -*- coding: utf-8 -*-
"""1 - Elaborazione Immagini - Soluzione Completa Shining.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EW7RLVnUxKo7i4Y1Z8Bw1JGticXxhpaR

# Introduzione al Laboratorio

Per usare un comando Linux in Colab, si mette ! davanti:
"""

!echo Hello World

"""Colab indenta normalmente con 2 spazi; se preferite 4 spazi, andate in Strumenti -> Impostazioni -> Editor

Durante il laboratorio useremo la repository [samuelemarro/ml_intro](https://github.com/samuelemarro/ml-intro), che contiene un paio di immagini di esempio e qualche funzione per scaricare e visualizzare immagini.
"""

!git clone https://github.com/samuelemarro/ml_intro

from ml_intro import utils, samples

utils.plot_image(samples.bird)

utils.plot_images(samples.standard_images, titles=samples.image_names, columns=4)

"""# Laboratorio 1 - Elaborazione Immagini

## Tensori

In informatica i tensori (noti anche come array n-dimensionali o ndarray) sono una generalizzazione dei vettori e delle matrici. In particolare:
- Un vettore è un tensore di rango 1 (1-tensore), perché basta un'indice per identificare un elemento
- Una matrice è un tensore di rango 2 (2-tensore), perché servono due indici per identificare un elemento
- Uno scalare è un tensore di rango 0 (0-tensore), perché non servono indici per identificare un elemento (dato che è un unico elemento)

Notazione: [2, 5] vuol dire un 2-tensore le cui dimensioni sono 2 e 5, ovvero una matrice 2x5.

## Immagini

Un'immagine a colori è essenzialmente un 3-tensore perché servono 3 indici: y, x e il colore (Red, Green, Blue). Quindi un'immagine HD 16:9 (che ha larghezza 1280 e altezza 720) avrà dimensioni [720, 1280, 3]. Nota che l'altezza viene prima. La coordinata (0, 0) corrisponde all'angolo in alto a sinistra.

## Spazi di Colore

Il modo in cui si associa un colore a una serie di numeri viene detto _spazio di colore_. Il più comune è RGB (Red, Green e Blue), che viene usato per gli schermi, ma esistono anche RBGA (che aggiunge Alpha, il canale per la trasparenza), Grayscale (che usa un solo canale, la luminosità), CMYK (Cyan, Magenta, Yellow e Key, usato per le stampanti), HSV e molti altri.

RGB si basa sul fatto che sommando luce rossa, verde e blu si possono ottenere tutti i colori:
<img width="500px" src="https://blog.hunterlab.com/blog/wp-content/uploads/2020/10/1-Additive-vs.-Subtractive-Color-Models.jpg"/>

Se la nostra immagine è in RGB, possiamo applicare funzioni matematiche ai valori di rosso, verde e blu. Per esempio:

### Isolare Canali
"""

red = samples.bird.copy() # Cloniamo per evitare di modificare l'immagine originale
red[:, :, 1] = 0 # Imposta il canale 1 (Verde) a 0
red[:, :, 2] = 0 # Imposta il canale 2 (Blu) a 0

green = samples.bird.copy()
green[:, :, 0] = 0 # Imposta il canale 0 (Rosso) a 0
green[:, :, 2] = 0 # Imposta il canale 2 (Blu) a 0

blue = samples.bird.copy()
blue[:, :, 0] = 0 # Imposta il canale 0 (Rosso) a 0
blue[:, :, 1] = 0 # Imposta il canale 1 (Verde) a 0

utils.plot_images([red, green, blue], titles=['Red', 'Green', 'Blue'], columns=3)

"""### Filtro rosso"""

import numpy as np

def red_filter(image):
    image = image.copy() # Per evitare di modificare l'immagine originale
    
    # Se aggiungessimo direttamente un numero a un'immagine a 8 bit, andremmo in overflow
    # Quindi convertiamo in interi a 16
    image = image.astype(np.uint16)

    image[:, :, 0] = image[:, :, 0] + 40 # Aggiungi 40 a [ogni y, ogni x, rosso]
    image = np.clip(image, 0, 255) # Se alcuni pixel sono > 255, impostali a 255
    return image.astype(np.uint8) # Riconverti a 8 bit

utils.plot_images([samples.bird, red_filter(samples.bird)])

"""### Interpolazione di due immagini


"""

def interpolate(image1, image2, coefficient): # 0 = tutto image1, 1 = tutto image2
    interpolated = image1 * (1 - coefficient) + image2 * coefficient
    # interpolated ora è un'immagine floating point, riconvertiamola in interi
    return interpolated.astype(np.uint8)

utils.plot_images([samples.bird, samples.tuscany, interpolate(samples.bird, samples.tuscany, 0.5)], columns=3)

"""### Schiarisci e scurisci"""

def darken(image):
    # Come prima, dobbiamo convertire in un formato che rappresenti correttamente i numeri negativi
    image = image.astype(np.int16)
    image = image - 40 # Riduci rosso, verde e blu di 40
    return np.clip(image, 0, 255).astype(np.uint8) # Se alcuni valori sono scesi sotto zero, impostali a zero

image = samples.bird
utils.plot_images([samples.bird, darken(samples.bird)])

"""### Effetto Polaroid

Le Polaroid rendono i colori chiari più chiari e i colori scuri più scuri. Si può ottenere una buona approssimazione di questo effetto usando una variante della funzione logistica:
"""

def scaled_logistic(x):
    return 1 / (1 + np.exp(-12 * x + 6))

x = np.linspace(0, 1, 100)
y = scaled_logistic(x)
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.plot(x, x, '--') # Mostra la retta y = x per confronto
plt.show()

def polaroid(image):
    image = image.astype(np.float32) / 255 # Converti in range [0, 1]
    image = scaled_logistic(image)
    image = (image * 255).astype(np.uint8) # Riconverti in range [0, 255]
    return image
utils.plot_images([samples.bird, polaroid(samples.bird)])

"""Interpolando l'immagine originale con la versione Polaroid si può modificare l'intensità dell'effetto:"""

def parametric_polaroid(image, coefficient):
    return interpolate(image, polaroid(image), coefficient)

images = []
titles = []

for coefficient in np.linspace(0, 1, num=6):
    images.append(parametric_polaroid(samples.bird, coefficient))
    titles.append(str(coefficient))

utils.plot_images(images, titles=titles, columns=3)

"""## Grayscale

Grayscale è un formato di file che usa un solo canale: la luminosità. Per questa ragione, le dimensioni di un'immagine grayscale sono [altezza, larghezza], visto che non ha senso avere un indice extra per scegliere il canale.
"""

import cv2 as cv

def to_grayscale(image):
    return cv.cvtColor(image, cv.COLOR_RGB2GRAY)

utils.plot_image(to_grayscale(samples.bird), space='gray')

"""## HSV

HSV è particolarmente comodo perché usa tre numeri molto intuitivi:
- Hue, ovvero la tinta tra i colori dell'arcobaleno (0 = rosso, 255 = violetto)
- Saturation, ovvero quanto i colori sono "vividi" (0 = colori sbiaditi, 255 = colori accesi)
- Value (nota anche come Brightness), ovvero la luminosità (0 = scuro, 255 = chiaro)


![](https://raw.githubusercontent.com/samuelemarro/ml_intro/master/teaching_material/picker.png)

<img width="300px" src="https://camo.githubusercontent.com/28eefd6e477a97d72893b29191f6ff434f034b6de3706c1f9b3b7fb2f975247f/68747470733a2f2f6c756e6368656f6e2e6769746875622e696f2f7265696e76656e7465642d636f6c6f722d776865656c2f696d6167652e706e67"/>

Per convertire un'immagine usiamo `cv.cvtColor`
"""

def to_hsv(image):
    # Converti in HSV
    return cv.cvtColor(image, cv.COLOR_RGB2HSV)

def to_rgb(image):
    # Converti in RGB
    return cv.cvtColor(image, cv.COLOR_HSV2RGB)

# plot_image interpreta l'immagine come se fosse in RGB
utils.plot_image(to_hsv(samples.bird))
# Per visualizzare un'immagine HSV, si passa il parametro space
utils.plot_image(to_hsv(samples.bird), space='hsv') # Case-insensitive

"""### Bianco e Nero"""

def hsv_grayscale(image):
  image = to_hsv(image)
  image[:, :, 1] = 0 # Impostiamo la saturazione a 0
  return to_rgb(image)

utils.plot_images([samples.bird, hsv_grayscale(samples.bird)])

"""### Schiarisci e scurisci in HSV"""

def hsv_darken(image):
  image = to_hsv(image)
  image = image.astype(np.int16) # Convertiamo in un formato che supporta numeri negativi
  image[:, :, 2] -= 40 # Togliamo 40 alla luminosità
  image = np.clip(image, 0, 255)
  image = image.astype(np.uint8)
  return to_rgb(image)

utils.plot_images([samples.bird, hsv_darken(samples.bird)])

"""### Interpolazione in HSV

Interpolazioni in spazi diversi portano a risultati diversi:
"""

def hsv_interpolate(image1, image2, coefficient):
    image1 = to_hsv(image1)
    image2 = to_hsv(image2)
    interpolated = interpolate(image1, image2, coefficient)
    return to_rgb(interpolated)

utils.plot_images([
    samples.bird,
    samples.tuscany,
    interpolate(samples.bird, samples.tuscany, 0.5),
    hsv_interpolate(samples.bird, samples.tuscany, 0.5)
  ],
  titles=['Image 1', 'Image 2', 'RGB interpolation', 'HSV interpolation'],
  columns=4
)

"""La differenza nell'interpolazione è particolarmente evidente con i gradienti:
![](https://pbs.twimg.com/media/FWvjrsUWQAMN3nC.jpg:large)

## Esercizio: Filtro Foto

La maggior parte dei filtri sono formule applicate all'immagine in uno o più spazi di colore. Instagram ha 11 filtri di default:
"""

utils.plot_images([samples.balloon] + samples.filter.images, titles=(['original'] + samples.filter.names), columns=4)

"""Scegliete un filtro e scrivete la funzione in modo che cv applichi lo stesso filtro (o che comunque esca molto simile).

<details>
<summary>Suggerimento</summary>
Ci sono modi molto più semplici di provare a mano per scegliere i parametri.
</details>
"""

def apply_filter(image):
    ...
    return image

reference_image = samples.filter.ludwig # Rimpiazza con il filtro scelto

transformed_image = apply_filter(samples.balloon)

distance = np.mean((reference_image - transformed_image) ** 2)
print('Distanza:', distance)

utils.plot_images([samples.balloon, reference_image, transformed_image], titles=['Original', 'Target', 'Result'], columns=3)

"""## Disegnare su un'Immagine

Per disegnare un'immagine si può modificare direttamente i pixel:
"""

def draw_square(image, x, y, size):
    image = image.copy() # Così non modifichiamo l'immagine originale
    image[y:y+size, x:x+size] = [255, 255, 0] # Rosso massimo, verde massimo, niente blu => giallo
    return image

utils.plot_image(draw_square(samples.bird, 251, 251, 100))

def draw_line(image, start_x, start_y, length):
    for i in range(length):
        image = draw_square(image, start_x + i, start_y + i, 10)
    return image
utils.plot_image(draw_line(samples.bird, 251, 251, 300))

"""cv semplifica questo processo con diverse funzioni:"""

# Queste funzioni modificano l'immagine di partenza, quindi facciamo sempre copie

# cv.rectangle(immagine, (x_topleft, y_topleft), (x_bottomright, y_bottomright), colore, spessore)
square_image = cv.rectangle(samples.bird.copy(), (100, 300), (150, 350), [255, 0, 0], 5)

# cv.line(immagine, (x_topleft, y_topleft), (x_bottomright, y_bottomright), colore, spessore)
line_image = cv.line(samples.bird.copy(), (100, 300), (500, 700), [255, 0, 0], 5)

# cv.circle(immagine, (centro_x, centro_y), raggio, colore, spessore)
circle_image = cv.circle(samples.bird.copy(), (500, 600), 100, [255, 0, 0], 5)

# cv.polylines vuole i punti di un poligono in maniera particolare (un array int32 di forma [numero punti, 1, 2])
points_1 = [(100, 200), (700, 600), (400, 800)]
points_1 = np.array(points_1, np.int32).reshape((len(points_1), 1, 2))

points_2 = [(900, 500), (1000, 600), (800, 800), (700, 700)]
points_2 = np.array(points_2, np.int32).reshape((len(points_2), 1, 2))

# cv.polylines(immagine, lista di poligoni, True se deve chiudere i poligoni, colore, spessore)
polygon_image = cv.polylines(samples.bird.copy(),[points_1, points_2], True, (255, 0, 0), 5)

# cv.putText(immagine, testo, (posizione_x, posizione_y), font, fattore di scala, colore, spessore)
text_image = cv.putText(samples.bird.copy(), 'UniBo', (400, 700), cv.FONT_HERSHEY_SIMPLEX, 4, [255, 0, 0], 5)

utils.plot_images([
    square_image,
    line_image,
    circle_image,
    polygon_image,
    text_image
])

"""## Sovraimporre immagini

Per sovrapporre un'immagine sopra un'altra basta rimpiazzare i pixel dell'immagine di partenza con quelli dell'immagine da sovrapporre:
"""

utils.plot_image(samples.special.sunglasses_noalpha)

# Gli occhiali da sole hanno dimensione [960, 480]

def composite(background, foreground, x, y):
    composite_image = background.copy()
    # Ricorda che quando si indicizza si indicizza prima con y e poi con x
    composite_image[y:y+foreground.shape[0], x:x+foreground.shape[1]] = foreground
    return composite_image

sunglasses = samples.special.sunglasses_noalpha

# Ridimensiona gli occhiali
sunglasses = cv.resize(sunglasses, (720, 360))

composite_image = composite(samples.bird, sunglasses, 180, 200)

utils.plot_image(composite_image)

"""Se l'immagine è in RGBA, possiamo scegliere l'immagine degli occhiali quando alpha è alto e l'immagine dell'uccello quando alpha è basso"""

def smart_fusion(base_image, rgba_image):
    # Separa il canale alpha dagli altri
    alpha_channel = rgba_image[:, :, 3] / 255
    rgb_channels = rgba_image[:, :, :3]

    alpha_channel = alpha_channel.reshape(alpha_channel.shape[0], alpha_channel.shape[1], 1)

    composite = rgb_channels * alpha_channel + base_image * (1 - alpha_channel)
    return composite.astype(np.uint8)

def smart_composite(base_image, added_image, x, y):
    # Crea un'immagine completamente trasparente della stessa dimensione di base_image
    rgba_image = np.zeros([1024, 1024, 4])

    # Aggiungici gli occhiali da sole (con canale alpha)
    rgba_image = composite(rgba_image, added_image, x, y)

    # Fondi le due immagini
    return smart_fusion(base_image, rgba_image)

sunglasses_alpha = cv.resize(samples.special.sunglasses_alpha, (720, 360))

utils.plot_image(smart_composite(samples.bird, sunglasses_alpha, 180, 200))

"""Se non abbiamo il canale Alpha, possiamo comunque "inventarcelo" dando 255 ai pixel da tenere e 0 ai pixel da rendere trasparenti"""

# Se Rosso, Verde e Blu sono tutti inferiori a 40, significa che è un pixel scuro
dark_pixels = np.logical_and(np.logical_and(sunglasses[:, :, 0] < 40, sunglasses[:, :, 1] < 40), sunglasses[:, :, 2] < 40)

# Convertiamo dark_pixels in interi invece che booleani
dark_pixels = dark_pixels.astype(np.uint8) # Ha valore 1 se il pixel è scuro, 0 se è chiaro
dark_pixels = dark_pixels * 255

# Dato che il canale è uno solo Matplotlib usa colori falsi (giallo = massimo, viola = minimo)
utils.plot_image(dark_pixels)

"""dark_pixels diventa il nostro canale Alpha:"""

# Crea un'immagine RGBA vuota della stessa dimensione degli occhiali
sunglasses_fakealpha = np.zeros([sunglasses.shape[0], sunglasses.shape[1], 4])

# Usa come canali RGB i canali RGB dell'immagine di partenza
sunglasses_fakealpha[:, :, 0:3] = sunglasses
sunglasses_fakealpha[:, :, 3] = dark_pixels

"""E quindi possiamo fare la composizione come con l'altra immagine:"""

utils.plot_image(smart_composite(samples.bird, sunglasses_fakealpha, 180, 200))

"""## Esercizio: Mascheramento

Realizzate la seguente immagine:

<img width="350" src= "https://raw.githubusercontent.com/samuelemarro/ml_intro/master/teaching_material/shining.png"/>

A partire dalle seguenti immagini:
"""

utils.plot_images([
    samples.shining.duvall, samples.shining.knife_mask, samples.shining.nicholson, samples.shining.title, samples.shining.wall
    ], titles=['duvall', 'knife_mask', 'nicholson', 'title', 'wall'], columns=3)

"""Le immagini sono già allineate correttamente.

<details>
<summary>Suggerimento</summary>
La documentazione ha molti font in più oltre a quello che abbiamo usato.
</details>
"""

# NOTA: Questa è la soluzione completa, realisticamente bastava fondere due immagini

def tint(image, red_diff, green_diff, blue_diff):
    image = np.copy(image).astype(np.int16)
    image[:, :, 0] += red_diff
    image[:, :, 1] += green_diff
    image[:, :, 2] += blue_diff
    return np.clip(image, 0, 255).astype(np.uint8)

def build_rgba(base_image, mask):
    rgba_image = np.zeros([base_image.shape[0], base_image.shape[1], 4])
    rgba_image[:, :, :3] = base_image
    rgba_image[:, :, 3] = mask
    return rgba_image

def shining():
    image_shape = [samples.shining.duvall.shape[0], samples.shining.duvall.shape[1]]

    # Partiamo con il muro
    wall_red = tint(samples.shining.wall, 0, -170, -170)

    # Aggiungiamoci nicholson usando la maschera del coltello
    nicholson_blue = tint(samples.shining.nicholson, -20, -50, 0)
    nicholson_blue_hsv = to_hsv(nicholson_blue)
    nicholson_blue_hsv[:, :, 1] -= 60
    nicholson_blue_hsv[:, :, 2] += 20
    nicholson_blue = to_rgb(nicholson_blue_hsv)
    knife_mask = (samples.shining.knife_mask[:, :, 0] > 128).astype(np.uint8) * 255 # Avrei potuto usare qualunque altro canale
    nicholson_rgba = build_rgba(nicholson_blue, knife_mask)
    fused = smart_fusion(wall_red, nicholson_rgba)

    # Facciamo duvall con tinta blu
    duvall_blue = tint(samples.shining.duvall, -50, -20, 0)
    # Esercizio extra: come avremmo potuto ottenere un effetto "coltello aggiuntivo"?

    # Fondiamo con la maschera di duvall
    duvall_alpha = np.logical_or(np.logical_or(samples.shining.duvall[:, :, 0] < 250, samples.shining.duvall[:, :, 1] < 250), samples.shining.duvall[:, :, 2] < 250)
    duvall_alpha = duvall_alpha.astype(np.uint8) * 255
    duvall_rgba = np.zeros([image_shape[0], image_shape[1], 4])
    duvall_rgba[:, :, :3] = duvall_blue
    duvall_rgba[:, :, 3] = duvall_alpha
    fused = smart_fusion(fused, duvall_rgba)

    # Aggiungiamo il titolo
    title_alpha = samples.shining.title[:, :, 0] > 200
    title_alpha = title_alpha.astype(np.uint8) * 255
    title_rgba = np.zeros([image_shape[0], image_shape[1], 4])
    title_rgba[:, :, :3] = samples.shining.title
    title_rgba[:, :, 3] = title_alpha

    fused = smart_fusion(fused, title_rgba)

    # E, infine, il testo
    fused = cv.putText(fused, 'JACK NICHOLSON', (100, 100), cv.FONT_HERSHEY_DUPLEX, 1.85, [255, 255, 255], 5)
    fused = cv.putText(fused, 'SHELLEY DUVAL', (750, 100), cv.FONT_HERSHEY_DUPLEX, 1.85, [255, 255, 255], 5)

    return fused

utils.plot_image(shining())

"""## Esercizio Extra: Effetto Poster

Photoshop permette di posterizzare un'immagine:

<img width="350" src= "https://raw.githubusercontent.com/samuelemarro/ml_intro/master/teaching_material/poster.png"/>

Scrivete una funzione che posterizzi (in maniera molto semplice) un'immagine.

<details>
<summary>Suggerimento</summary>
Ci sono molti modi per fare questo esercizio, alcuni più raffinati di altri. Dividere il range 0-255 in "blocchi" di una certa dimensione permette di avere risultati piuttosto buoni.
</details>
"""

def posterize(image):
    return image

utils.plot_images([samples.bird, posterize(samples.bird)], titles=['original', 'posterized'])