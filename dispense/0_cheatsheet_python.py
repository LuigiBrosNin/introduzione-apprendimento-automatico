# -*- coding: utf-8 -*-
"""0 - Cheatsheet Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sbuq9DJgbl4xr-cgQX-h9MRZhliQtnco

# Basi di Sintassi

## Hello World
"""

print('Hello world!')
print('Hello', 'world!')
s = 'Hello world!'
print(s)

"""## If"""

a = 2

if a == 1:
  print('a vale 1') # L'indentazione è obbligatoria
elif a == 2:
  print('a vale 2')
else:
  print('a ha un altro valore')

"""## While"""

i = 0
while i < 10:
  i += 1 # Python non ha ++
  if i == 2:
    continue # continue e break funzionano come negli altri linguaggi
  if i == 7:
    break
  print(i)

"""## For"""

# Questi tre loop sono equivalenti

i = 0
while i < 10:
  print(i, end=' ')
  i += 1

print()

for i in range(10):
  print(i, end=' ')

print()

for i in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]: # Parentesi quadre = lista
  print(i, end=' ')

# La sintassi di range (quando prende 3 parametri) è range(inizio, fine, step)
# Quindi range(1, 10, 2) è equivalente a fare for(i = 1; i < 10; i += 2)

"""## Conversioni"""

x1 = '12'
print('Tipo di x1:', type(x1))

x2 = int('12')
print('Tipo di x2:', type(x2))
print('Valore di x2:', x2)

x3 = float('12')
print('Tipo di x3:', type(x3))
print('Valore di x3:', x3)

x3_converted = str(x3)
print(type(x3_converted))

"""# Operazioni"""

# Sono tutte uguali, con due eccezioni:
# // fa la divisione intera (approssimando per difetto)
print(7 / 2)
print(7 // 2)

# ** fa la potenza
print(5 ** 2)

"""## Import"""

import abc # Caricalo normalmente
print(abc.abstractmethod)

import abc as modulo_abc # Caricalo e dagli il nome modulo_abc
print(modulo_abc.abstractmethod)

from abc import abstractmethod # Carica solo abstractmethod
print(abstractmethod)

from abc import * # Carica tutti i componenti di abc
print(abstractmethod)

"""## Try"""

try:
  x = 2 / 0
except ZeroDivisionError as e:
  print(e)
finally:
  print('Questo viene eseguito a prescindere')

"""## Trucchi vari"""

# Stampa i metodi e le proprietà di un oggetto
x = 'ciao'
print(dir(x))

# String interpolations
print(f'il valore di x è {x}')

# Concatenazione di liste
a = [1, 2, 3] + [4, 5, 6]
print(a)

# Controlla se un elemento è in una lista
print(2 in [1, 2, 3, 4])

# Scambia il valore di due variabili
x = 2
y = 3
x, y = y, x
print(x, y)

# Ripeti un carattere o una stringa
print('=.' * 30)

# List comprehensions
b = [x ** 2 for x in range(10) if x % 2 == 0] # Prendi i numeri da 0 a 9 incluso, scegli solo i numeri pari ed eleva al quadrato
print(b)

# range non dà una lista: bisogna convertirlo
c = list(range(10))
print(c[2])

"""# NumPy"""

import numpy as np

"""## Creare un tensore"""

a = np.array([10, 5, 4, 2])
print('=' * 10, 'A', '=' * 10)
print(a)
print(a.shape)

b = np.zeros([10, 5]) # Crea una matrice 10x5 di zeri
print('=' * 10, 'B', '=' * 10)
print(b)
print(b.shape)
# Vedi anche np.ones

print('=' * 10, 'C', '=' * 10)
c = np.arange(10) # Come range()
print(c)
print(c.shape)

print('=' * 10, 'D', '=' * 10)
d = np.linspace(0, 1, 20) # Prendi 20 numeri equidistanziati tra 0 e 1 (inclusi gli estremi)
print(d)
print(d.shape)

"""## Indicizzare"""

a = np.arange(10) # Crea un vettore di lunghezza 10
print(a)
print('2 =>', a[2]) # Prendi l'elemento di indice 2
print('-1 =>', a[-1]) # Prendi l'ultimo elemento
print('-2 =>', a[-2]) # Prendi il penultimo elemento
print(':3 =>', a[:3]) # Prendi i primi 3 elementi
print('2:5 =>', a[2:5]) # Prendi gli elementi con indice in [2, 3, 4]
print('1:8:2 =>', a[1:8:2]) # Equivalente a fare for(i = 1; i < 8; i += 2) 
print(': =>', a[:]) # Prendi tutti gli elementi

b = np.arange(20).reshape(5, 4) # Crea una matrice di dimensione [5, 4]
print(b)
print()
print('2, 3 =>', b[2, 3]) # Prendi l'elemento con indici 2 e 3
print('1, 1 =>', b[1, :3]) # Prendi tutti gli elementi con primo indice 1 e secondo indice in [0, 1, 2] => ottieni un vettore di lunghezza 3
print('1:3, 2:4 =>\n', b[1:3, 2:4]) # Prendi tutti gli elementi con primo indice in [1, 2] e secondo indice in [2, 3] => ottieni una matrice 2x2
print(':, 1 =>', b[:, 1]) # Prendi tutti gli elementi con qualunque primo indice e con secondo indice 1

"""## Cambiare forma"""

a = np.arange(20)
print(a.reshape(5, 4)) # Row-first (noto anche come C-like indexing)
print(a.reshape(5, 4, order='F')) # Column-first (noto anche come Fortran-like indexing)

# IMPORTANTE: .reshape non fa una copia dell'array sottostante, cambia solo come viene visualizzato!

# Appiattire
b = np.arange(20).reshape(5, 4)
print(b.flatten())
print(b.reshape(-1)) # Equivalente

# Aggiungere dimensioni nuove

c = np.arange(20).reshape(5, 4)
# Tutte i seguenti metodi sono equivalenti
c1 = c.reshape(1, 5, 4)
print(c1.shape)
c2 = c.reshape((1,) + c.shape)
print(c2.shape)
c3 = np.expand_dims(c, 0)
print(c3.shape)

"""## Broadcasting

Quando viene eseguita un'operazione tra due ndarray di rango diverso (es. una matrice e un vettore), se possibile NumPy cercherà di eseguirla lo stesso "ripetendo" il più piccolo. Questo fenomeno viene detto _broadcasting_.
"""

a = np.arange(20).reshape(5, 4) # a ha dimensione [5, 4]
print(a)
print(a + 0.1) # Equivalente ad aggiungere una matrice [5, 4] contenente tutti 0.1
b = np.array([0.1, 0.2, 0.3, 0.4])
print(a + b) # Equivalente ad aggiungere una matrice [5, 4] contenente il vettore b ripetuto su ogni riga

"""Il broadcasting funziona anche se ci sono delle dimensioni "1"
"""

a = np.arange(20).reshape(5, 4) # a ha dimensione [5, 4]
b = np.array(0.1).reshape(1, 1) # b in teoria sarebe uno scalare, ma viene salvato come una matrice [1, 1]
print(a + b) # Stessa cosa di fare a + 0.1